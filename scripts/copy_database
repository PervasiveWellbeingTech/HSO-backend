#!/usr/bin/env node
// Generated by LiveScript 1.5.0
(function(){
  var mongodb, getsecret, fs, n2p, storage, mongourl, mongourl2, local_cache_db, getdb_running, get_mongo_db, local_cache_db2, getdb_running2, get_mongo_db2, sync_all_in_collection, sync_all_in_collection_fresh, list_collections, out$ = typeof exports != 'undefined' && exports || this;
  mongodb = require('mongodb');
  getsecret = require('getsecret');
  fs = require('fs');
  n2p = require('n2p');
  storage = require('node-persist');
  mongourl = getsecret('MONGODB_SRC');
  mongourl2 = getsecret('MONGODB_DST');
  local_cache_db = null;
  getdb_running = false;
  out$.get_mongo_db = get_mongo_db = async function(){
    var err;
    if (local_cache_db != null) {
      return local_cache_db;
    }
    if (getdb_running) {
      while (getdb_running) {
        (await sleep(1));
      }
      while (getdb_running || local_cache_db === null) {
        (await sleep(1));
      }
      return local_cache_db;
    }
    getdb_running = true;
    try {
      local_cache_db = (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          w: 0
        }, it);
      }));
      return local_cache_db;
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb');
      console.error(err);
    }
  };
  local_cache_db2 = null;
  getdb_running2 = false;
  out$.get_mongo_db2 = get_mongo_db2 = async function(){
    var err;
    if (local_cache_db2 != null) {
      return local_cache_db2;
    }
    if (getdb_running2) {
      while (getdb_running2) {
        (await sleep(1));
      }
      while (getdb_running2 || local_cache_db2 === null) {
        (await sleep(1));
      }
      return local_cache_db2;
    }
    getdb_running2 = true;
    try {
      local_cache_db2 = (await n2p(function(it){
        return mongodb.MongoClient.connect(mongourl2, {
          readPreference: mongodb.ReadPreference.SECONDARY,
          w: 0
        }, it);
      }));
      return local_cache_db2;
    } catch (e$) {
      err = e$;
      console.error('error getting mongodb2');
      console.error(err);
    }
  };
  sync_all_in_collection = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_ids_src, all_ids_dst, dst_id_set, all_ids_which_need_to_be_inserted, all_items_src, all_items_which_need_to_be_inserted, this$ = this;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_ids_src = (await n2p(function(it){
      return c_src.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_src = all_ids_src.map(function(it){
      return it._id;
    }).map(function(it){
      return it.toString();
    });
    if (all_ids_src.length === 0) {
      return;
    }
    all_ids_dst = (await n2p(function(it){
      return c_dst.find({}, {
        _id: 1
      }).toArray(it);
    }));
    all_ids_dst = all_ids_dst.map(function(it){
      return it._id;
    }).map(function(it){
      return it.toString();
    });
    dst_id_set = new Set(all_ids_dst);
    all_ids_which_need_to_be_inserted = all_ids_src.filter(function(x){
      return !dst_id_set.has(x);
    });
    if (all_ids_which_need_to_be_inserted.length === 0) {
      return;
    }
    all_items_src = (await n2p(function(it){
      return c_src.find({}).toArray(it);
    }));
    if (all_items_src.length === 0) {
      return;
    }
    all_items_which_need_to_be_inserted = all_items_src.filter(function(x){
      return !dst_id_set.has(x._id.toString());
    });
    if (all_items_which_need_to_be_inserted.length === 0) {
      return;
    }
    console.log('incrementally inserting ' + all_items_which_need_to_be_inserted.length + ' items');
    return (await n2p(function(it){
      return c_dst.insertMany(all_items_which_need_to_be_inserted, it);
    }));
  };
  sync_all_in_collection_fresh = async function(collection_name, db_src, db_dst){
    var c_src, c_dst, all_items_src;
    c_src = db_src.collection(collection_name);
    c_dst = db_dst.collection(collection_name);
    all_items_src = (await n2p(function(it){
      return c_src.find({}).toArray(it);
    }));
    if (all_items_src.length === 0) {
      return;
    }
    console.log('freshly inserting ' + all_items_src.length + ' items');
    return (await n2p(function(it){
      return c_dst.insertMany(all_items_src, it);
    }));
  };
  list_collections = async function(db_src){
    var collections_src, all_items_src, this$ = this;
    collections_src = db_src.collection('collections');
    all_items_src = (await n2p(function(it){
      return collections_src.find({}).toArray(it);
    }));
    return all_items_src.map(function(it){
      return it._id;
    });
  };
  (async function(){
    var db_src, db_dst, all_collections, dst_collections, dst_collections_set, num_to_sync, num_threads, resumable, start_thread, i$, threadnum, results$ = [];
    db_src = (await get_mongo_db());
    db_dst = (await get_mongo_db2());
    if (!fs.existsSync('listcollections')) {
      all_collections = (await list_collections(db_src));
      fs.writeFileSync('listcollections', JSON.stringify(all_collections), 'utf-8');
    } else {
      all_collections = JSON.parse(fs.readFileSync('listcollections', 'utf-8'));
    }
    dst_collections = (await list_collections(db_dst));
    dst_collections_set = new Set(dst_collections);
    num_to_sync = all_collections.length;
    num_threads = 1;
    resumable = true;
    if (resumable) {
      storage.initSync();
    }
    start_thread = async function(threadnum){
      var i$, ref$, len$, idx, x, is_incremental, results$ = [];
      for (i$ = 0, len$ = (ref$ = all_collections).length; i$ < len$; ++i$) {
        idx = i$;
        x = ref$[i$];
        if (idx % num_threads !== threadnum) {
          continue;
        }
        if (resumable && storage.getItemSync(x)) {
          console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' already synced ' + x);
          continue;
        }
        console.log('' + idx + '/' + num_to_sync + ' thread ' + threadnum + ' syncing ' + x);
        is_incremental = dst_collections_set.has(x);
        if (is_incremental) {
          (await sync_all_in_collection(x, db_src, db_dst));
        } else {
          (await sync_all_in_collection_fresh(x, db_src, db_dst));
        }
        if (resumable) {
          results$.push(storage.setItemSync(x, true));
        }
      }
      return results$;
    };
    for (i$ = 0; i$ < num_threads; ++i$) {
      threadnum = i$;
      results$.push(start_thread(threadnum));
    }
    return results$;
  })();
}).call(this);
